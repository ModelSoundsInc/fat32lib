<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>sdlib/sd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
    <tbody>
        <tr>
            <td id="projectlogo" style="text-align:left; padding-left: 0.5em;">
                <img alt="Logo" width="100" height="50" src="fat32lib.png" />
            </td>
        </tr>
        <tr style="background-image:url('tab_b.png'); height:30px">
            <td>
                <table cellspacing="0" cellpadding="0">
                    <tr>
                        <td style="padding-left: 0.5em;">
                            <div id="projectbrief">File System Stack for Embedded Devices</div>
                        </td>
                        <td style="vertical-align:middle">
                            <div>&nbsp;        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sd_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the header file for the SD card driver. It handles the SD card access through the SPI bus driver implemented on the HAL library and provides a <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> interface to the higher level drivers (fat32lib and smlib.)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___c_a_l_l_b_a_c_k___i_n_f_o.html">PSD_CALLBACK_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by the SD driver to store callback information about a request. It is reserved for internal use and should not be accessed directly by the application code.  <a href="struct_s_d___c_a_l_l_b_a_c_k___i_n_f_o.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html">SD_CALLBACK_INFO_EX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by the SD driver to store callback information about a request. It is reserved for internal use and should not be accessed directly by the application code.  <a href="struct_s_d___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___a_s_y_n_c___r_e_q_u_e_s_t.html">SD_ASYNC_REQUEST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used by the SD driver to store information about asynchronous requests. It is reserved for internal use and should not be accessed directly by the application code.  <a href="struct_s_d___a_s_y_n_c___r_e_q_u_e_s_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___d_r_i_v_e_r___c_o_n_t_e_x_t.html">SD_DRIVER_CONTEXT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure stores the state of the SD card driver. It is part of the driver handle (<a class="el" href="struct_s_d___d_r_i_v_e_r.html" title="The SD card device driver handle. The members of this structure are reserved for internal use and sho...">SD_DRIVER</a>) and as such it is reserved for internal use and should not be accessed by the application directly.  <a href="struct_s_d___d_r_i_v_e_r___c_o_n_t_e_x_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___c_a_r_d.html">SD_CARD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure stores information about the currently mounted SD card. It is part of the device driver handle (<a class="el" href="struct_s_d___d_r_i_v_e_r.html" title="The SD card device driver handle. The members of this structure are reserved for internal use and sho...">SD_DRIVER</a> structure) and as such it is reserved for internal use and should not be accessed by the application directly.  <a href="struct_s_d___c_a_r_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SD card device driver handle. The members of this structure are reserved for internal use and should not be accessed by the application directly.  <a href="struct_s_d___d_r_i_v_e_r.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8f79280fb51f110595325733cc63a252"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a8f79280fb51f110595325733cc63a252">SD_MULTI_THREADED</a></td></tr>
<tr class="memdesc:a8f79280fb51f110595325733cc63a252"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option used the enable multi-threading support. WARNING: At the present time multi-threading support has not been fully tested.  <a href="#a8f79280fb51f110595325733cc63a252">More...</a><br/></td></tr>
<tr class="separator:a8f79280fb51f110595325733cc63a252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabe8727df891449a86bb98dced689d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#afabe8727df891449a86bb98dced689d7">SD_DRIVER_OWNS_THREAD</a></td></tr>
<tr class="memdesc:afabe8727df891449a86bb98dced689d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option to indicate that the driver has it's own background processing thread, or more specifically that none of the IO functions will ever be called by application code from the same thread as sd_idle_processing. It only applies when SD_MULTI_THREADED is defined.  <a href="#afabe8727df891449a86bb98dced689d7">More...</a><br/></td></tr>
<tr class="separator:afabe8727df891449a86bb98dced689d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6f4043f08d64e9f8e97be1b859c865"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a1a6f4043f08d64e9f8e97be1b859c865">SD_QUEUE_ASYNC_REQUESTS</a></td></tr>
<tr class="memdesc:a1a6f4043f08d64e9f8e97be1b859c865"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option that defines whether the driver should enqueue asynchronous requests (including stream IO requests.) If your application only uses 1 asynchronous IO concurrently you can comment this line out in order to save space.  <a href="#a1a6f4043f08d64e9f8e97be1b859c865">More...</a><br/></td></tr>
<tr class="separator:a1a6f4043f08d64e9f8e97be1b859c865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22abe6bef8c645ee03fa63076f3bdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a7e22abe6bef8c645ee03fa63076f3bdb">SD_ASYNC_QUEUE_LIMIT</a></td></tr>
<tr class="memdesc:a7e22abe6bef8c645ee03fa63076f3bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option that defines the number of asynchronous requests that the driver can handle simultaneously. After this limit is exceeded any asynchronous requests will block until one requests is completed.  <a href="#a7e22abe6bef8c645ee03fa63076f3bdb">More...</a><br/></td></tr>
<tr class="separator:a7e22abe6bef8c645ee03fa63076f3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e815dfd89efb9d7115ebc58b7b1fdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a40e815dfd89efb9d7115ebc58b7b1fdc">SD_ALLOCATE_QUEUE_FROM_HEAP</a></td></tr>
<tr class="memdesc:a40e815dfd89efb9d7115ebc58b7b1fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option that defines that the driver should allocate memory for the request queue dynamically from the heap. If memory is not available when an asynchronous request is made it will block until the memory becomes available. This option is not supported with SD_ENABLE_MULTI_BLOCK_WRITE.  <a href="#a40e815dfd89efb9d7115ebc58b7b1fdc">More...</a><br/></td></tr>
<tr class="separator:a40e815dfd89efb9d7115ebc58b7b1fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26410b5fc22f25fa27918674ac2edffa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a26410b5fc22f25fa27918674ac2edffa">SD_ENABLE_MULTI_BLOCK_WRITE</a></td></tr>
<tr class="memdesc:a26410b5fc22f25fa27918674ac2edffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a compile-time option that indicates that the driver should be compile with multi-sector write support. This option is required to support stream IO. If your application does not use stream IO you may comment this option out in order to save space.  <a href="#a26410b5fc22f25fa27918674ac2edffa">More...</a><br/></td></tr>
<tr class="separator:a26410b5fc22f25fa27918674ac2edffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df589db0d265eba2980ae4b4f37feec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a7df589db0d265eba2980ae4b4f37feec">SD_DMA_CHANNEL_1_INTERRUPT</a>(driver)</td></tr>
<tr class="memdesc:a7df589db0d265eba2980ae4b4f37feec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the macro for driver's 1st DMA channel interrupt. It must be called from within that channel's ISR.  <a href="#a7df589db0d265eba2980ae4b4f37feec">More...</a><br/></td></tr>
<tr class="separator:a7df589db0d265eba2980ae4b4f37feec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d2ea58163dc2f023b6120a366cfc84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a70d2ea58163dc2f023b6120a366cfc84">SD_DMA_CHANNEL_2_INTERRUPT</a>(driver)</td></tr>
<tr class="memdesc:a70d2ea58163dc2f023b6120a366cfc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the macro for driver's 2nd DMA channel interrupt. It must be called from within that channel's ISR.  <a href="#a70d2ea58163dc2f023b6120a366cfc84">More...</a><br/></td></tr>
<tr class="separator:a70d2ea58163dc2f023b6120a366cfc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af83589b0e9a35ef77ec35c51abece9c0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#af83589b0e9a35ef77ec35c51abece9c0">SD_ASYNC_CALLBACK</a> )(uint16_t *result, void *context)</td></tr>
<tr class="memdesc:af83589b0e9a35ef77ec35c51abece9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer required by the file system driver for the asynchronous IO callback. The file system driver implements this functions and passes it's pointer to the asynchronous IO functions in order to receive callbacks.  <a href="#af83589b0e9a35ef77ec35c51abece9c0">More...</a><br/></td></tr>
<tr class="separator:af83589b0e9a35ef77ec35c51abece9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9327abfbe70f62fbaa4c4ce57f81a8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#aff9327abfbe70f62fbaa4c4ce57f81a8">SD_MEDIA_STATE_CHANGED</a> )(uint16_t device_id, char media_ready)</td></tr>
<tr class="memdesc:aff9327abfbe70f62fbaa4c4ce57f81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer required by the volume manager (smlib) to receive notifications when the device is mounted of dismounted. The Volume Manager registers this function when the device is registered with the Volume Manager.  <a href="#aff9327abfbe70f62fbaa4c4ce57f81a8">More...</a><br/></td></tr>
<tr class="separator:aff9327abfbe70f62fbaa4c4ce57f81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac54576c36417914762125aeaa4215"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#afbac54576c36417914762125aeaa4215">SD_ASYNC_CALLBACK_EX</a> )(uint16_t *result, void *context, unsigned char **buffer, uint16_t *response)</td></tr>
<tr class="memdesc:afbac54576c36417914762125aeaa4215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer required by the file system driver for the stream IO callback. The file system driver implements this functions and passes it's pointer to the write_multiple_sectors functions in order to receive callbacks.  <a href="#afbac54576c36417914762125aeaa4215">More...</a><br/></td></tr>
<tr class="separator:afbac54576c36417914762125aeaa4215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae33f572960cab587a1bd584593dc96fe"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#ae33f572960cab587a1bd584593dc96fe">sd_init</a> (<a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *driver, SPI_MODULE spi_module, DMA_CHANNEL *const dma_channel_1, DMA_CHANNEL *const dma_channel_2, unsigned char *dma_buffer, char *dma_byte, BIT_POINTER media_ready, BIT_POINTER cs_line, BIT_POINTER busy_signal, uint16_t id)</td></tr>
<tr class="memdesc:ae33f572960cab587a1bd584593dc96fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SD card driver. <a href="#ae33f572960cab587a1bd584593dc96fe">More...</a><br/></td></tr>
<tr class="separator:ae33f572960cab587a1bd584593dc96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd9d61f0880e1c579db25f380e69efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#afbd9d61f0880e1c579db25f380e69efc">sd_get_storage_device_interface</a> (<a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *driver, <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html">STORAGE_DEVICE</a> *driver_interface)</td></tr>
<tr class="memdesc:afbd9d61f0880e1c579db25f380e69efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> interface used by the fat32lib and smlib modules to communicate with the device.  <a href="#afbd9d61f0880e1c579db25f380e69efc">More...</a><br/></td></tr>
<tr class="separator:afbd9d61f0880e1c579db25f380e69efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5570b11e5e686829e8b083e072c03b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sd_8h.html#a5570b11e5e686829e8b083e072c03b62">sd_idle_processing</a> (<a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *driver)</td></tr>
<tr class="memdesc:a5570b11e5e686829e8b083e072c03b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the driver's background processing. This function should be called from within your applications main loop.  <a href="#a5570b11e5e686829e8b083e072c03b62">More...</a><br/></td></tr>
<tr class="separator:a5570b11e5e686829e8b083e072c03b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the header file for the SD card driver. It handles the SD card access through the SPI bus driver implemented on the HAL library and provides a <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> interface to the higher level drivers (fat32lib and smlib.) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a40e815dfd89efb9d7115ebc58b7b1fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ALLOCATE_QUEUE_FROM_HEAP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option that defines that the driver should allocate memory for the request queue dynamically from the heap. If memory is not available when an asynchronous request is made it will block until the memory becomes available. This option is not supported with SD_ENABLE_MULTI_BLOCK_WRITE. </p>

</div>
</div>
<a class="anchor" id="a7e22abe6bef8c645ee03fa63076f3bdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ASYNC_QUEUE_LIMIT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option that defines the number of asynchronous requests that the driver can handle simultaneously. After this limit is exceeded any asynchronous requests will block until one requests is completed. </p>

</div>
</div>
<a class="anchor" id="a7df589db0d265eba2980ae4b4f37feec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_DMA_CHANNEL_1_INTERRUPT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">driver</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the macro for driver's 1st DMA channel interrupt. It must be called from within that channel's ISR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>A pointer to the driver handle.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70d2ea58163dc2f023b6120a366cfc84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_DMA_CHANNEL_2_INTERRUPT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">driver</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the macro for driver's 2nd DMA channel interrupt. It must be called from within that channel's ISR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>A pointer to the driver handle.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afabe8727df891449a86bb98dced689d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_DRIVER_OWNS_THREAD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option to indicate that the driver has it's own background processing thread, or more specifically that none of the IO functions will ever be called by application code from the same thread as sd_idle_processing. It only applies when SD_MULTI_THREADED is defined. </p>

</div>
</div>
<a class="anchor" id="a26410b5fc22f25fa27918674ac2edffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ENABLE_MULTI_BLOCK_WRITE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option that indicates that the driver should be compile with multi-sector write support. This option is required to support stream IO. If your application does not use stream IO you may comment this option out in order to save space. </p>

</div>
</div>
<a class="anchor" id="a8f79280fb51f110595325733cc63a252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_MULTI_THREADED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option used the enable multi-threading support. WARNING: At the present time multi-threading support has not been fully tested. </p>

</div>
</div>
<a class="anchor" id="a1a6f4043f08d64e9f8e97be1b859c865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_QUEUE_ASYNC_REQUESTS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a compile-time option that defines whether the driver should enqueue asynchronous requests (including stream IO requests.) If your application only uses 1 asynchronous IO concurrently you can comment this line out in order to save space. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af83589b0e9a35ef77ec35c51abece9c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SD_ASYNC_CALLBACK)(uint16_t *result, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer required by the file system driver for the asynchronous IO callback. The file system driver implements this functions and passes it's pointer to the asynchronous IO functions in order to receive callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result of the asynchronous IO operation.</td></tr>
    <tr><td class="paramname">context</td><td>A pointer passed by the file system driver to the storage device driver that contains state information about the async operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbac54576c36417914762125aeaa4215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SD_ASYNC_CALLBACK_EX)(uint16_t *result, void *context, unsigned char **buffer, uint16_t *response)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer required by the file system driver for the stream IO callback. The file system driver implements this functions and passes it's pointer to the write_multiple_sectors functions in order to receive callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result of the asynchronous IO operation.</td></tr>
    <tr><td class="paramname">context</td><td>A pointer passed by the file system driver to the storage device driver that contains state information about the async operation. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer-to-pointer to the buffer containing the data being read/written to/from the device. During this callback the file system driver may change the buffer or reload it with fresh data to continue the multiple sector transfer. </td></tr>
    <tr><td class="paramname">response</td><td>A pointer to the response code. The file system driver may set this value to STORAGE_MULTI_SECTOR_RESPONSE_STOP to signal that the multi sector operation is completed, to STORAGE_MULTI_SECTOR_RESPONSE_SKIP to signal that the multi-sector operation is not completed but the data is not ready to be written. In this case the driver should enqueue the request, process other pending request and callback again. Or to STORAGE_MULTI_SECTOR_RESPONSE_READY to indicate that the buffer has been changed or releaded with fresh data and that the multi-sector operation should continue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff9327abfbe70f62fbaa4c4ce57f81a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SD_MEDIA_STATE_CHANGED)(uint16_t device_id, char media_ready)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer required by the volume manager (smlib) to receive notifications when the device is mounted of dismounted. The Volume Manager registers this function when the device is registered with the Volume Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_id</td><td>The id of the device. This is the value passed as the id parameter to sd_init . </td></tr>
    <tr><td class="paramname">media_ready</td><td>A boolean value that is set to 1 to indicate that the device has been mounted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afbd9d61f0880e1c579db25f380e69efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sd_get_storage_device_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html">STORAGE_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>driver_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> interface used by the fat32lib and smlib modules to communicate with the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>A pointer to the initialized driver handle (<a class="el" href="struct_s_d___d_r_i_v_e_r.html" title="The SD card device driver handle. The members of this structure are reserved for internal use and sho...">SD_DRIVER</a> structure). </td></tr>
    <tr><td class="paramname">driver_interface</td><td>A pointer to a <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> structure to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5570b11e5e686829e8b083e072c03b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sd_idle_processing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the driver's background processing. This function should be called from within your applications main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>A pointer to the driver handle (<a class="el" href="struct_s_d___d_r_i_v_e_r.html" title="The SD card device driver handle. The members of this structure are reserved for internal use and sho...">SD_DRIVER</a> structure.)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae33f572960cab587a1bd584593dc96fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_d___d_r_i_v_e_r.html">SD_DRIVER</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPI_MODULE&#160;</td>
          <td class="paramname"><em>spi_module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CHANNEL *const&#160;</td>
          <td class="paramname"><em>dma_channel_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DMA_CHANNEL *const&#160;</td>
          <td class="paramname"><em>dma_channel_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>dma_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dma_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIT_POINTER&#160;</td>
          <td class="paramname"><em>media_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIT_POINTER&#160;</td>
          <td class="paramname"><em>cs_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BIT_POINTER&#160;</td>
          <td class="paramname"><em>busy_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SD card driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>A pointer to the driver handle (<a class="el" href="struct_s_d___d_r_i_v_e_r.html" title="The SD card device driver handle. The members of this structure are reserved for internal use and sho...">SD_DRIVER</a> structure)</td></tr>
    <tr><td class="paramname">spi_module</td><td>The SPI module used to connect to the SD card.</td></tr>
    <tr><td class="paramname">dma_channel_1</td><td>The 1st DMA channel used by the driver. This is only required for asynchronous (and stream) IO. If you don't use this features you can set this paramter to zero. Use the DMA_GET_CHANNEL() macro included in the HAL library to initialize a DMA channel instance. </td></tr>
    <tr><td class="paramname">dma_channel_2</td><td>The 2nd DMA channel used by the driver. This is only required for asynchronous (and stream) IO. If you don't use this features you can set this paramter to zero. Use the DMA_GET_CHANNEL() macro included in the HAL library to initialize a DMA channel instance. </td></tr>
    <tr><td class="paramname">dma_buffer</td><td>DMA buffer used by the driver. This is only required for asynchronous (and stream) IO. If your application doesn't use this features you can set this parameter to zero. </td></tr>
    <tr><td class="paramname">dma_byte</td><td>A byte of DMA memory. This is only required by asynchronous IO in order to sustain a DMA transfer through the SPI since since the SPI bus requires that reads and writes be done simultaneously in order to sustain a transfer. If your application does not use asynchronous IO you can set this parameter to zero. </td></tr>
    <tr><td class="paramname">cs_line</td><td>A pointer to the pin that is connected to the CS line of the SD card. Use the BP_INIT macro included in the HAL library to initialize a bit pointer. </td></tr>
    <tr><td class="paramname">busy_signal</td><td>A pointer to a pin (or a bit of memory) that will be set HIGH by the driver during disk activity. </td></tr>
    <tr><td class="paramname">id</td><td>A unique device id. This is used by smlib to identify the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return SD_SUCCESS, otherwise it will return one of the result codes defined in <a class="el" href="sd_8h.html" title="This is the header file for the SD card driver. It handles the SD card access through the SPI bus dri...">sd.h</a>. </dd></dl>
<p>The interrupts for dma_channel_1 and dma_channel_2 must by handled with the <a class="el" href="sd_8h.html#a7df589db0d265eba2980ae4b4f37feec" title="This is the macro for driver&#39;s 1st DMA channel interrupt. It must be called from within that channel&#39;...">SD_DMA_CHANNEL_1_INTERRUPT()</a> and <a class="el" href="sd_8h.html#a70d2ea58163dc2f023b6120a366cfc84" title="This is the macro for driver&#39;s 2nd DMA channel interrupt. It must be called from within that channel&#39;...">SD_DMA_CHANNEL_2_INTERRUPT()</a> macros. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_9c7224fc5b6514418c4231fda2ae6875.html">sdlib</a></li><li class="navelem"><a class="el" href="sd_8h.html">sd.h</a></li>
    <li class="footer">Copyright &copy; 2013 by <a href="mailto:frodriguez.developer@outlook.com">Fernando Rodriguez</a></li>
  </ul>
</div>
</body>
</html>
