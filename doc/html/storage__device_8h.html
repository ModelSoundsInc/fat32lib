<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>fat32lib/storage_device.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
    <tbody>
        <tr>
            <td id="projectlogo" style="text-align:left; padding-left: 0.5em;">
                <img alt="Logo" width="100" height="50" src="fat32lib.png" />
            </td>
        </tr>
        <tr style="background-image:url('tab_b.png'); height:30px">
            <td>
                <table cellspacing="0" cellpadding="0">
                    <tr>
                        <td style="padding-left: 0.5em;">
                            <div id="projectbrief">File System Stack for Embedded Devices</div>
                        </td>
                        <td style="vertical-align:middle">
                            <div>&nbsp;        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('storage__device_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">storage_device.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the interface between this module and the underlying storage device driver. All storage device driver must implement all the functions defined in this file in order to fully support the File32Lib File System Stack.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html">PSTORAGE_CALLBACK_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds the callback function pointer and the callback context and is passed by the file system driver as a parameter to the driver's asynchronous IO functions.  <a href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html">PSTORAGE_CALLBACK_INFO_EX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds the callback function pointer and the callback context and is passed by the file system driver as a parameter to the driver's multiple sector functions.  <a href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html">PSTORAGE_DEVICE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the interface between fat32lib and the underlying storage device driver.  <a href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8cfeb478a2294054266f82f1d4376e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cfeb478a2294054266f82f1d4376e3c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_SUCCESS</b></td></tr>
<tr class="separator:a8cfeb478a2294054266f82f1d4376e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5f3392675cee7920de603e1dc201d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81e5f3392675cee7920de603e1dc201d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_VOLTAGE_NOT_SUPPORTED</b></td></tr>
<tr class="separator:a81e5f3392675cee7920de603e1dc201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab122a02e5f66c688ea3d10ee981e8df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab122a02e5f66c688ea3d10ee981e8df3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_INVALID_MEDIA</b></td></tr>
<tr class="separator:ab122a02e5f66c688ea3d10ee981e8df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c30c59dc793f33928c0c8e27086f26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10c30c59dc793f33928c0c8e27086f26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_UNKNOWN_ERROR</b></td></tr>
<tr class="separator:a10c30c59dc793f33928c0c8e27086f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb080eefda89b82026af9f9edd0f04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1adb080eefda89b82026af9f9edd0f04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_INVALID_PARAMETER</b></td></tr>
<tr class="separator:a1adb080eefda89b82026af9f9edd0f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880dcbbee631c432cc864bea40e022a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a880dcbbee631c432cc864bea40e022a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_ADDRESS_ERROR</b></td></tr>
<tr class="separator:a880dcbbee631c432cc864bea40e022a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c95bc831d9d0e71cf7feb7aae1125d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c95bc831d9d0e71cf7feb7aae1125d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_ERASE_SEQ_ERROR</b></td></tr>
<tr class="separator:a6c95bc831d9d0e71cf7feb7aae1125d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e2da2d30d2cad9293d05d1df59763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae41e2da2d30d2cad9293d05d1df59763"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_CRC_ERROR</b></td></tr>
<tr class="separator:ae41e2da2d30d2cad9293d05d1df59763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e047704acfb6066bd7400d034138015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e047704acfb6066bd7400d034138015"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_ILLEGAL_COMMAND</b></td></tr>
<tr class="separator:a8e047704acfb6066bd7400d034138015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c7dd634d748a246ebc4176715f022c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c7dd634d748a246ebc4176715f022c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_ERASE_RESET</b></td></tr>
<tr class="separator:a14c7dd634d748a246ebc4176715f022c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c63c239779620fabd9f6d48e2d2f2c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c63c239779620fabd9f6d48e2d2f2c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_COMMUNICATION_ERROR</b></td></tr>
<tr class="separator:a3c63c239779620fabd9f6d48e2d2f2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bd419c1e682a374d1d4b8c85c95149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48bd419c1e682a374d1d4b8c85c95149"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_TIMEOUT</b></td></tr>
<tr class="separator:a48bd419c1e682a374d1d4b8c85c95149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec85ad68913e38ff6ef85c967cbf32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eec85ad68913e38ff6ef85c967cbf32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_IDLE</b></td></tr>
<tr class="separator:a8eec85ad68913e38ff6ef85c967cbf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eaa33b3be4b1e0bb64d01ca707f0b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5eaa33b3be4b1e0bb64d01ca707f0b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_OUT_OF_RANGE</b></td></tr>
<tr class="separator:aa5eaa33b3be4b1e0bb64d01ca707f0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3999bd4c92e3e55e92e1217c8b2d7e1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3999bd4c92e3e55e92e1217c8b2d7e1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_MEDIA_ECC_FAILED</b></td></tr>
<tr class="separator:a3999bd4c92e3e55e92e1217c8b2d7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6c5ee1209c328d3e0802a0165cf886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6c5ee1209c328d3e0802a0165cf886"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_CC_ERROR</b></td></tr>
<tr class="separator:a1d6c5ee1209c328d3e0802a0165cf886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e3b9f799a15a8b901df4f79d3b5751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e3b9f799a15a8b901df4f79d3b5751"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_OP_IN_PROGRESS</b></td></tr>
<tr class="separator:ab0e3b9f799a15a8b901df4f79d3b5751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a73ff4225991caa81b3177076e1b28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0a73ff4225991caa81b3177076e1b28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_MEDIUM_WRITE_PROTECTED</b></td></tr>
<tr class="separator:ac0a73ff4225991caa81b3177076e1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3daecb5b10dd9fc2befacedb36b1e1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3daecb5b10dd9fc2befacedb36b1e1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_OUT_OF_SPACE</b></td></tr>
<tr class="separator:ac3daecb5b10dd9fc2befacedb36b1e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b1542fd5e9e8efd4a1e0c09a9dae73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44b1542fd5e9e8efd4a1e0c09a9dae73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_DEVICE_NOT_READY</b></td></tr>
<tr class="separator:a44b1542fd5e9e8efd4a1e0c09a9dae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb152e1a970c676d72f5a1acd012be3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb152e1a970c676d72f5a1acd012be3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_AWAITING_DATA</b></td></tr>
<tr class="separator:abb152e1a970c676d72f5a1acd012be3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b736b513aec15a13bad579c7e939493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b736b513aec15a13bad579c7e939493"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_INVALID_MULTI_BLOCK_RESPONSE</b></td></tr>
<tr class="separator:a0b736b513aec15a13bad579c7e939493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7a7a76c1d86494ed8a4de0ba67c192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca7a7a76c1d86494ed8a4de0ba67c192"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_MULTI_SECTOR_RESPONSE_STOP</b></td></tr>
<tr class="separator:aca7a7a76c1d86494ed8a4de0ba67c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361d7ea6e5d4af9319492f3353099e2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a361d7ea6e5d4af9319492f3353099e2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_MULTI_SECTOR_RESPONSE_SKIP</b></td></tr>
<tr class="separator:a361d7ea6e5d4af9319492f3353099e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f4642832a777ffb2538a03af47d5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a304f4642832a777ffb2538a03af47d5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STORAGE_MULTI_SECTOR_RESPONSE_READY</b></td></tr>
<tr class="separator:a304f4642832a777ffb2538a03af47d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8cb14eb6b3a551384eb60e31ac041cbf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a8cb14eb6b3a551384eb60e31ac041cbf">STORAGE_MEDIA_CHANGED_CALLBACK</a> )(uint16_t device_id, char media_state)</td></tr>
<tr class="memdesc:a8cb14eb6b3a551384eb60e31ac041cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the media state changed callback function. It is called by the device driver in order to notify the volume manager whenever the device is mounted or dismounted.  <a href="#a8cb14eb6b3a551384eb60e31ac041cbf">More...</a><br/></td></tr>
<tr class="separator:a8cb14eb6b3a551384eb60e31ac041cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a06fa2f13791fdfef68daaf9be36cca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a2a06fa2f13791fdfef68daaf9be36cca">STORAGE_REGISTER_MEDIA_CHANGED_CALLBACK</a> )(void *device, <a class="el" href="storage__device_8h.html#a8cb14eb6b3a551384eb60e31ac041cbf">STORAGE_MEDIA_CHANGED_CALLBACK</a> callback)</td></tr>
<tr class="memdesc:a2a06fa2f13791fdfef68daaf9be36cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function used to register a callback function to receive notifications when the device is mounted or dismounted. It is called by the volume manager driver to register a STORAGE_MEDIA_CHANGED_CALLBACK function.  <a href="#a2a06fa2f13791fdfef68daaf9be36cca">More...</a><br/></td></tr>
<tr class="separator:a2a06fa2f13791fdfef68daaf9be36cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2525e2e402d76190ce2899bee8e3e95f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a2525e2e402d76190ce2899bee8e3e95f">STORAGE_CALLBACK</a> )(void *context, uint16_t *result)</td></tr>
<tr class="memdesc:a2525e2e402d76190ce2899bee8e3e95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the callback function for an asynchronous operation.  <a href="#a2525e2e402d76190ce2899bee8e3e95f">More...</a><br/></td></tr>
<tr class="separator:a2525e2e402d76190ce2899bee8e3e95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4194d733562a00352768c1b70de17c58"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a4194d733562a00352768c1b70de17c58">STORAGE_CALLBACK_EX</a> )(void *context, uint16_t *result, unsigned char **buffer, uint16_t *response)</td></tr>
<tr class="memdesc:a4194d733562a00352768c1b70de17c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the callback function for multi-sector operations.  <a href="#a4194d733562a00352768c1b70de17c58">More...</a><br/></td></tr>
<tr class="separator:a4194d733562a00352768c1b70de17c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7125ce05706a819e46d6c2ebf97928"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#acc7125ce05706a819e46d6c2ebf97928">STORAGE_DEVICE_GET_SECTOR_SIZE</a> )(void *device)</td></tr>
<tr class="memdesc:acc7125ce05706a819e46d6c2ebf97928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer to the driver function that gets the sector size.  <a href="#acc7125ce05706a819e46d6c2ebf97928">More...</a><br/></td></tr>
<tr class="separator:acc7125ce05706a819e46d6c2ebf97928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b847f9b2df6590b1b14dfb6575deac"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a45b847f9b2df6590b1b14dfb6575deac">STORAGE_DEVICE_GET_SECTOR_COUNT</a> )(void *device)</td></tr>
<tr class="memdesc:a45b847f9b2df6590b1b14dfb6575deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer to the driver function that gets the number of sectors on the storage device.  <a href="#a45b847f9b2df6590b1b14dfb6575deac">More...</a><br/></td></tr>
<tr class="separator:a45b847f9b2df6590b1b14dfb6575deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d216465274a38c59861f351fbee3b"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#af00d216465274a38c59861f351fbee3b">STORAGE_GET_DEVICE_ID</a> )(void *device)</td></tr>
<tr class="memdesc:af00d216465274a38c59861f351fbee3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer to the driver function that gets the device id.  <a href="#af00d216465274a38c59861f351fbee3b">More...</a><br/></td></tr>
<tr class="separator:af00d216465274a38c59861f351fbee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe467b72922f1756858de3e2deaf94e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a1fe467b72922f1756858de3e2deaf94e">STORAGE_GET_PAGE_SIZE</a> )(void *device)</td></tr>
<tr class="memdesc:a1fe467b72922f1756858de3e2deaf94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function pointer to the driver function that gets the size of flash pages. This function should return 1 for non-flash devices.  <a href="#a1fe467b72922f1756858de3e2deaf94e">More...</a><br/></td></tr>
<tr class="separator:a1fe467b72922f1756858de3e2deaf94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac29d59cad4aa6b856ab9e30b2524d9"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a1ac29d59cad4aa6b856ab9e30b2524d9">STORAGE_DEVICE_READ</a> )(void *device, uint32_t sector_address, unsigned char *buffer)</td></tr>
<tr class="memdesc:a1ac29d59cad4aa6b856ab9e30b2524d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to read a sector.  <a href="#a1ac29d59cad4aa6b856ab9e30b2524d9">More...</a><br/></td></tr>
<tr class="separator:a1ac29d59cad4aa6b856ab9e30b2524d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41871d7ad5089165d8402920362738e1"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a41871d7ad5089165d8402920362738e1">STORAGE_DEVICE_READ_ASYNC</a> )(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html">STORAGE_CALLBACK_INFO</a> *callback_info)</td></tr>
<tr class="memdesc:a41871d7ad5089165d8402920362738e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to read a sector asynchronously.  <a href="#a41871d7ad5089165d8402920362738e1">More...</a><br/></td></tr>
<tr class="separator:a41871d7ad5089165d8402920362738e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef195bdadc0119e278762678ab4cefe"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a2ef195bdadc0119e278762678ab4cefe">STORAGE_DEVICE_ERASE_SECTORS</a> )(void *device, uint32_t start_sector_address, uint32_t end_sector_address)</td></tr>
<tr class="memdesc:a2ef195bdadc0119e278762678ab4cefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to erase flash pages. For non-flash devices this function should always return STORAGE_SUCCESS without doing any work.  <a href="#a2ef195bdadc0119e278762678ab4cefe">More...</a><br/></td></tr>
<tr class="separator:a2ef195bdadc0119e278762678ab4cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635f038e97e18a68f64834b77995b20d"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a635f038e97e18a68f64834b77995b20d">STORAGE_DEVICE_WRITE</a> )(void *device, uint32_t sector_address, unsigned char *buffer)</td></tr>
<tr class="memdesc:a635f038e97e18a68f64834b77995b20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to write a sector to the device.  <a href="#a635f038e97e18a68f64834b77995b20d">More...</a><br/></td></tr>
<tr class="separator:a635f038e97e18a68f64834b77995b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3d463d7a8989022ecab678bcfd5f47"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#abb3d463d7a8989022ecab678bcfd5f47">STORAGE_DEVICE_WRITE_ASYNC</a> )(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, PSTORAGE_CALLBACK_INFO callback_info)</td></tr>
<tr class="memdesc:abb3d463d7a8989022ecab678bcfd5f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to write a sector to the device asynchronously.  <a href="#abb3d463d7a8989022ecab678bcfd5f47">More...</a><br/></td></tr>
<tr class="separator:abb3d463d7a8989022ecab678bcfd5f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ff9813608571cba01ce45ab5bdb2e"><td class="memItemLeft" align="right" valign="top">typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="storage__device_8h.html#a3e7ff9813608571cba01ce45ab5bdb2e">STORAGE_DEVICE_WRITE_MULTIPLE_SECTORS</a> )(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html">STORAGE_CALLBACK_INFO_EX</a> *callback_info)</td></tr>
<tr class="memdesc:a3e7ff9813608571cba01ce45ab5bdb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the driver function used to write multiple sectors to the device asynchronously. This function actually writes one sector at a time but calls back as soon as the sector is written (or while it is still programming in the case of flash memory) to reload the data and continue writing. This allows us to use the multiple block write feature of flash devices without having to allocate large buffers to store the data that is being written, so we get the performance advantage of using multiple sector writes without the expense of large buffers.  <a href="#a3e7ff9813608571cba01ce45ab5bdb2e">More...</a><br/></td></tr>
<tr class="separator:a3e7ff9813608571cba01ce45ab5bdb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the interface between this module and the underlying storage device driver. All storage device driver must implement all the functions defined in this file in order to fully support the File32Lib File System Stack. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2525e2e402d76190ce2899bee8e3e95f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* STORAGE_CALLBACK)(void *context, uint16_t *result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the callback function for an asynchronous operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context pointer of the asynchronous operation.</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to the result of the asynchronous operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4194d733562a00352768c1b70de17c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* STORAGE_CALLBACK_EX)(void *context, uint16_t *result, unsigned char **buffer, uint16_t *response)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the callback function for multi-sector operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context of the multi-sector operation.</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to the result or current status of the multi-sector operation.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the multi-sector operation buffer. </td></tr>
    <tr><td class="paramname">response</td><td>A pointer that the file system driver must set in order to signal how the storage device driver should proceed with the asynchronous operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="storage__device_8h.html#a3e7ff9813608571cba01ce45ab5bdb2e" title="A function pointer to the driver function used to write multiple sectors to the device asynchronously...">STORAGE_DEVICE_WRITE_MULTIPLE_SECTORS</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2ef195bdadc0119e278762678ab4cefe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_ERASE_SECTORS)(void *device, uint32_t start_sector_address, uint32_t end_sector_address)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to erase flash pages. For non-flash devices this function should always return STORAGE_SUCCESS without doing any work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">start_sector_address</td><td>A 32-bit unsigned integer representing the address of the 1st sector to erase.</td></tr>
    <tr><td class="paramname">end_sector_address</td><td>A 32-bit unsigned integer representing the address of the last sector to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a></dd></dl>

</div>
</div>
<a class="anchor" id="a45b847f9b2df6590b1b14dfb6575deac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* STORAGE_DEVICE_GET_SECTOR_COUNT)(void *device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer to the driver function that gets the number of sectors on the storage device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit unsigned integer that represents the number of sectors on the storage device. </dd></dl>

</div>
</div>
<a class="anchor" id="acc7125ce05706a819e46d6c2ebf97928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_GET_SECTOR_SIZE)(void *device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer to the driver function that gets the sector size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit unsigned integer that represents the sector size usually ()though not necessarily always) 512 bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ac29d59cad4aa6b856ab9e30b2524d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_READ)(void *device, uint32_t sector_address, unsigned char *buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to read a sector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">sector_address</td><td>A 32-bit unsigned integer representing the address of the sector to be read</td></tr>
    <tr><td class="paramname">buffer</td><td>A sector sized buffer where the sector data will be copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a41871d7ad5089165d8402920362738e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_READ_ASYNC)(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html">STORAGE_CALLBACK_INFO</a> *callback_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to read a sector asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">sector_address</td><td>A 32-bit unsigned integer representing the address of the sector to be read.</td></tr>
    <tr><td class="paramname">buffer</td><td>A sector-sized buffer where the sector data will be copied to.</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit unsigned integer where the result of the asynchronous operation will be stored. </td></tr>
    <tr><td class="paramname">callback_info</td><td>A pointer to a <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html" title="This structure holds the callback function pointer and the callback context and is passed by the file...">STORAGE_CALLBACK_INFO</a> structure that holds the callback function pointer and a context pointer that will be passed back to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it should return STORAGE_OP_IN_PROGRESS, otherwise it should return one of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a635f038e97e18a68f64834b77995b20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_WRITE)(void *device, uint32_t sector_address, unsigned char *buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to write a sector to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">sector_address</td><td>A 32-bit unsigned integer representing the address of the sector to be written.</td></tr>
    <tr><td class="paramname">buffer</td><td>A sector-sized buffer containing the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a></dd></dl>

</div>
</div>
<a class="anchor" id="abb3d463d7a8989022ecab678bcfd5f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_WRITE_ASYNC)(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, PSTORAGE_CALLBACK_INFO callback_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to write a sector to the device asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">sector_address</td><td>A 32-bit unsigned integer representing the address of the sector to be written.</td></tr>
    <tr><td class="paramname">buffer</td><td>A sector-sized buffer containing the data to be written.</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit integer where the result of the asynchronous operation will be written to. </td></tr>
    <tr><td class="paramname">callback_info</td><td>A pointer to a <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o.html" title="This structure holds the callback function pointer and the callback context and is passed by the file...">STORAGE_CALLBACK_INFO</a> structure that holds the callback function pointer and a context pointer that will be passed back to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it should return STORAGE_OP_IN_PROGRESS, otherwise it should return one of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e7ff9813608571cba01ce45ab5bdb2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_DEVICE_WRITE_MULTIPLE_SECTORS)(void *device, uint32_t sector_address, unsigned char *buffer, uint16_t *result, <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html">STORAGE_CALLBACK_INFO_EX</a> *callback_info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to the driver function used to write multiple sectors to the device asynchronously. This function actually writes one sector at a time but calls back as soon as the sector is written (or while it is still programming in the case of flash memory) to reload the data and continue writing. This allows us to use the multiple block write feature of flash devices without having to allocate large buffers to store the data that is being written, so we get the performance advantage of using multiple sector writes without the expense of large buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">sector_address</td><td>A 32-bit unsigned integer representing the address of the 1st sector to be written. </td></tr>
    <tr><td class="paramname">buffer</td><td>A sector-sized buffer containing the 1st sector of data to be written.</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit unsigned integer where the result of the multiple-sector write operation will be stored once the operation completes. </td></tr>
    <tr><td class="paramname">callback_info</td><td>A pointer to a <a class="el" href="struct_s_t_o_r_a_g_e___c_a_l_l_b_a_c_k___i_n_f_o___e_x.html" title="This structure holds the callback function pointer and the callback context and is passed by the file...">STORAGE_CALLBACK_INFO_EX</a> structure that holds the callback function pointer and a context pointer that will be passed back to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it should return STORAGE_OP_IN_PROGRESS, otherwise one of the result codes defined in <a class="el" href="storage__device_8h.html" title="This file defines the interface between this module and the underlying storage device driver...">storage_device.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af00d216465274a38c59861f351fbee3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t(* STORAGE_GET_DEVICE_ID)(void *device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer to the driver function that gets the device id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit unsigned integer that uniquely identifies the device. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fe467b72922f1756858de3e2deaf94e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* STORAGE_GET_PAGE_SIZE)(void *device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function pointer to the driver function that gets the size of flash pages. This function should return 1 for non-flash devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit unsigned integer that represents the size of the flash page in sectors. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cb14eb6b3a551384eb60e31ac041cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* STORAGE_MEDIA_CHANGED_CALLBACK)(uint16_t device_id, char media_state)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the media state changed callback function. It is called by the device driver in order to notify the volume manager whenever the device is mounted or dismounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_id</td><td>A 16-bit unsigned integer that uniquely identifies the device.</td></tr>
    <tr><td class="paramname">media_state</td><td>A boolean value that is set to 1 to indicate that the device has been mounted and to 0 to indicate that it has been dismounted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a06fa2f13791fdfef68daaf9be36cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* STORAGE_REGISTER_MEDIA_CHANGED_CALLBACK)(void *device, <a class="el" href="storage__device_8h.html#a8cb14eb6b3a551384eb60e31ac041cbf">STORAGE_MEDIA_CHANGED_CALLBACK</a> callback)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function used to register a callback function to receive notifications when the device is mounted or dismounted. It is called by the volume manager driver to register a STORAGE_MEDIA_CHANGED_CALLBACK function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device driver handle.</td></tr>
    <tr><td class="paramname">callback</td><td>A pointer to the function that will be called when the device is mounted or dismounted.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bddc50b92baa9add6b6d72ffa81b8add.html">fat32lib</a></li><li class="navelem"><a class="el" href="storage__device_8h.html">storage_device.h</a></li>
    <li class="footer">Copyright &copy; 2013 by <a href="mailto:frodriguez.developer@outlook.com">Fernando Rodriguez</a></li>
  </ul>
</div>
</body>
</html>
