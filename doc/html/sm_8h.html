<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>smlib/sm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
    <tbody>
        <tr>
            <td id="projectlogo" style="text-align:left; padding-left: 0.5em;">
                <img alt="Logo" width="100" height="50" src="fat32lib.png" />
            </td>
        </tr>
        <tr style="background-image:url('tab_b.png'); height:30px">
            <td>
                <table cellspacing="0" cellpadding="0">
                    <tr>
                        <td style="padding-left: 0.5em;">
                            <div id="projectbrief">File System Stack for Embedded Devices</div>
                        </td>
                        <td style="vertical-align:middle">
                            <div>&nbsp;        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sm_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sm.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header file contains all the functions needed to mount and dismount drives, register file system drivers, and perform file I/O operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the handle of a directory query. All the fields in this structure are reserved for internal use and should not be accessed directly by the developer.  <a href="struct_s_m___q_u_e_r_y.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the file handle structure. All fields in this structure are reserved for internal use and should not be used directly by the developer.  <a href="struct_s_m___f_i_l_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure used to store information about a directory entry. It is usually populated by sm_get_file_entry, sm_find_first_entry, and sm_find_next_entry.  <a href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a82e1efb377618c5d91702264871be160"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a82e1efb377618c5d91702264871be160">SM_ATTR_READ_ONLY</a></td></tr>
<tr class="memdesc:a82e1efb377618c5d91702264871be160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file is read-only. <a href="#a82e1efb377618c5d91702264871be160">More...</a><br/></td></tr>
<tr class="separator:a82e1efb377618c5d91702264871be160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7597c5e2c9f86c51f933ad5eb2651be6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a7597c5e2c9f86c51f933ad5eb2651be6">SM_ATTR_HIDDEN</a></td></tr>
<tr class="memdesc:a7597c5e2c9f86c51f933ad5eb2651be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file is hidden. <a href="#a7597c5e2c9f86c51f933ad5eb2651be6">More...</a><br/></td></tr>
<tr class="separator:a7597c5e2c9f86c51f933ad5eb2651be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac045c573c3d3422457555c0aa1f24585"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ac045c573c3d3422457555c0aa1f24585">SM_ATTR_SYSTEM</a></td></tr>
<tr class="memdesc:ac045c573c3d3422457555c0aa1f24585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file is a system file. <a href="#ac045c573c3d3422457555c0aa1f24585">More...</a><br/></td></tr>
<tr class="separator:ac045c573c3d3422457555c0aa1f24585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ffb0c448ba030c3bb0d0591fc58c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a9b3ffb0c448ba030c3bb0d0591fc58c0">SM_ATTR_VOLUME_ID</a></td></tr>
<tr class="memdesc:a9b3ffb0c448ba030c3bb0d0591fc58c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file entry is the volume ID. <a href="#a9b3ffb0c448ba030c3bb0d0591fc58c0">More...</a><br/></td></tr>
<tr class="separator:a9b3ffb0c448ba030c3bb0d0591fc58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a3f8b383bfab2b56fb838c2c66f040"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a54a3f8b383bfab2b56fb838c2c66f040">SM_ATTR_DIRECTORY</a></td></tr>
<tr class="memdesc:a54a3f8b383bfab2b56fb838c2c66f040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the entry is a directory. <a href="#a54a3f8b383bfab2b56fb838c2c66f040">More...</a><br/></td></tr>
<tr class="separator:a54a3f8b383bfab2b56fb838c2c66f040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806e497325bcbdb648e34708dde24af3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a806e497325bcbdb648e34708dde24af3">SM_ATTR_ARCHIVE</a></td></tr>
<tr class="memdesc:a806e497325bcbdb648e34708dde24af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file is to be archived. <a href="#a806e497325bcbdb648e34708dde24af3">More...</a><br/></td></tr>
<tr class="separator:a806e497325bcbdb648e34708dde24af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc50cea776c48a709911da856ad83b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#afdc50cea776c48a709911da856ad83b2">SM_FILE_ACCESS_READ</a></td></tr>
<tr class="memdesc:afdc50cea776c48a709911da856ad83b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file should be opened for read access. <a href="#afdc50cea776c48a709911da856ad83b2">More...</a><br/></td></tr>
<tr class="separator:afdc50cea776c48a709911da856ad83b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5ea23c380beac7f91336fde56f614"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a2bd5ea23c380beac7f91336fde56f614">SM_FILE_ACCESS_WRITE</a></td></tr>
<tr class="memdesc:a2bd5ea23c380beac7f91336fde56f614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file should be opened for write access. <a href="#a2bd5ea23c380beac7f91336fde56f614">More...</a><br/></td></tr>
<tr class="separator:a2bd5ea23c380beac7f91336fde56f614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65385aa0bf57e84bfa08754fe0718050"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a65385aa0bf57e84bfa08754fe0718050">SM_FILE_ACCESS_APPEND</a></td></tr>
<tr class="memdesc:a65385aa0bf57e84bfa08754fe0718050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that if the file exists it should be opened in append mode. <a href="#a65385aa0bf57e84bfa08754fe0718050">More...</a><br/></td></tr>
<tr class="separator:a65385aa0bf57e84bfa08754fe0718050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d450d717247164fdd6cde51cc84634d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a2d450d717247164fdd6cde51cc84634d">SM_FILE_ACCESS_OVERWRITE</a></td></tr>
<tr class="memdesc:a2d450d717247164fdd6cde51cc84634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that if the file exists it should be overwritten. <a href="#a2d450d717247164fdd6cde51cc84634d">More...</a><br/></td></tr>
<tr class="separator:a2d450d717247164fdd6cde51cc84634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f600c4ad23ebe265282ff5daeafdb9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a4f600c4ad23ebe265282ff5daeafdb9e">SM_FILE_ACCESS_CREATE</a></td></tr>
<tr class="memdesc:a4f600c4ad23ebe265282ff5daeafdb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that if the file does not exists it should be created. <a href="#a4f600c4ad23ebe265282ff5daeafdb9e">More...</a><br/></td></tr>
<tr class="separator:a4f600c4ad23ebe265282ff5daeafdb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6590de3f1d996c8f1ee18774df54a273"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a6590de3f1d996c8f1ee18774df54a273">SM_FILE_FLAG_NO_BUFFERING</a></td></tr>
<tr class="memdesc:a6590de3f1d996c8f1ee18774df54a273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file should be opened in unbuffered mode. <a href="#a6590de3f1d996c8f1ee18774df54a273">More...</a><br/></td></tr>
<tr class="separator:a6590de3f1d996c8f1ee18774df54a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0643c921c365b78a89196ebcbd47dd0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a0643c921c365b78a89196ebcbd47dd0c">SM_FILE_FLAG_OPTIMIZE_FOR_FLASH</a></td></tr>
<tr class="memdesc:a0643c921c365b78a89196ebcbd47dd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the file should be optimized for flash stream writes. <a href="#a0643c921c365b78a89196ebcbd47dd0c">More...</a><br/></td></tr>
<tr class="separator:a0643c921c365b78a89196ebcbd47dd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a752f1a1eaca0183f6b9910c281d02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ac8a752f1a1eaca0183f6b9910c281d02">SM_SEEK_START</a></td></tr>
<tr class="memdesc:ac8a752f1a1eaca0183f6b9910c281d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the seek operation should start at the beginning of the file. <a href="#ac8a752f1a1eaca0183f6b9910c281d02">More...</a><br/></td></tr>
<tr class="separator:ac8a752f1a1eaca0183f6b9910c281d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4a35a4b252549dbf658bdf22c07df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a59a4a35a4b252549dbf658bdf22c07df">SM_SEEK_CURRENT</a></td></tr>
<tr class="memdesc:a59a4a35a4b252549dbf658bdf22c07df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the seek operation should start at the current position. <a href="#a59a4a35a4b252549dbf658bdf22c07df">More...</a><br/></td></tr>
<tr class="separator:a59a4a35a4b252549dbf658bdf22c07df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda07779eb4d21b067319dd9d23424fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#abda07779eb4d21b067319dd9d23424fa">SM_SEEK_END</a></td></tr>
<tr class="memdesc:abda07779eb4d21b067319dd9d23424fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specified that the seek operation should set the file pointer at the end of the file. <a href="#abda07779eb4d21b067319dd9d23424fa">More...</a><br/></td></tr>
<tr class="separator:abda07779eb4d21b067319dd9d23424fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c951d31b1d1d2ca3e2f4d6569f4ef68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c951d31b1d1d2ca3e2f4d6569f4ef68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SM_STREAM_RESPONSE_READY</b></td></tr>
<tr class="separator:a3c951d31b1d1d2ca3e2f4d6569f4ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd0f8ba23fb4cfc1fc3508ba6353aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd0f8ba23fb4cfc1fc3508ba6353aa0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SM_STREAM_RESPONSE_SKIP</b></td></tr>
<tr class="separator:a8fd0f8ba23fb4cfc1fc3508ba6353aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b93e8206686bbc035ebc35cbd35929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b93e8206686bbc035ebc35cbd35929"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SM_STREAM_RESPONSE_STOP</b></td></tr>
<tr class="separator:a88b93e8206686bbc035ebc35cbd35929"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5a9e84d8f6dcc8b7adefda60ac17c34b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a5a9e84d8f6dcc8b7adefda60ac17c34b">SM_VOLUME_MOUNTED_CALLBACK</a> )(char *label)</td></tr>
<tr class="memdesc:a5a9e84d8f6dcc8b7adefda60ac17c34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is pointer is used to register for notifications when a new volume is mounted. Once you register this function with sm_register_volume_mounted_callback it will be called by this module every time a new volume is mounted.  <a href="#a5a9e84d8f6dcc8b7adefda60ac17c34b">More...</a><br/></td></tr>
<tr class="separator:a5a9e84d8f6dcc8b7adefda60ac17c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6ecb4a67a9ac01594b9ef8808cb8d5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a9e6ecb4a67a9ac01594b9ef8808cb8d5">SM_VOLUME_DISMOUNTED_CALLBACK</a> )(char *label)</td></tr>
<tr class="memdesc:a9e6ecb4a67a9ac01594b9ef8808cb8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is pointer is used to register for notifications when a new volume is dimounted. Once you register this function with sm_register_volume_dismounted_callback it will be called by this module every time a new volume is dismounted.  <a href="#a9e6ecb4a67a9ac01594b9ef8808cb8d5">More...</a><br/></td></tr>
<tr class="separator:a9e6ecb4a67a9ac01594b9ef8808cb8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1a8249a2f33303ac6869ba5472500f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a1b1a8249a2f33303ac6869ba5472500f">SM_ASYNC_CALLBACK</a> )(void *context, uint16_t *result)</td></tr>
<tr class="memdesc:a1b1a8249a2f33303ac6869ba5472500f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the callback function for asynchronous IO. You can pass a pointer of this type of any of the asynchronous IO functions and it will be called when the operation completes.  <a href="#a1b1a8249a2f33303ac6869ba5472500f">More...</a><br/></td></tr>
<tr class="separator:a1b1a8249a2f33303ac6869ba5472500f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07c3c837f09898814640e8d5c12725a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#af07c3c837f09898814640e8d5c12725a">SM_STREAM_CALLBACK</a> )(void *context, uint16_t *result, unsigned char **buffer, uint16_t *response)</td></tr>
<tr class="memdesc:af07c3c837f09898814640e8d5c12725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the callback function for asynchronous STREAM IO. You MUST pass a pointer of this type to sm_file_write_stream. When it finished writting your buffer it will call this function.  <a href="#af07c3c837f09898814640e8d5c12725a">More...</a><br/></td></tr>
<tr class="separator:af07c3c837f09898814640e8d5c12725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ada581ecde0fce91bb9d3bc21ef4e165b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ada581ecde0fce91bb9d3bc21ef4e165b">sm_register_volume_mounted_callback</a> (<a class="el" href="sm_8h.html#a5a9e84d8f6dcc8b7adefda60ac17c34b">SM_VOLUME_MOUNTED_CALLBACK</a> callback)</td></tr>
<tr class="memdesc:ada581ecde0fce91bb9d3bc21ef4e165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback function that will be called everytime a volume is mounted.  <a href="#ada581ecde0fce91bb9d3bc21ef4e165b">More...</a><br/></td></tr>
<tr class="separator:ada581ecde0fce91bb9d3bc21ef4e165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12cf90dfc90777d18c4af288c415aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ac12cf90dfc90777d18c4af288c415aa6">sm_register_volume_dismounted_callback</a> (<a class="el" href="sm_8h.html#a9e6ecb4a67a9ac01594b9ef8808cb8d5">SM_VOLUME_DISMOUNTED_CALLBACK</a> callback)</td></tr>
<tr class="memdesc:ac12cf90dfc90777d18c4af288c415aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback function that will be called everytime a volume is dismounted.  <a href="#ac12cf90dfc90777d18c4af288c415aa6">More...</a><br/></td></tr>
<tr class="separator:ac12cf90dfc90777d18c4af288c415aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07206242f3ccfa230cc193b15425c2b9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a07206242f3ccfa230cc193b15425c2b9">sm_register_filesystem</a> (<a class="el" href="struct_f_i_l_e_s_y_s_t_e_m.html">FILESYSTEM</a> *filesystem)</td></tr>
<tr class="memdesc:a07206242f3ccfa230cc193b15425c2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a filesystem with smlib. This function needs to be called before a drive can be mounted.  <a href="#a07206242f3ccfa230cc193b15425c2b9">More...</a><br/></td></tr>
<tr class="separator:a07206242f3ccfa230cc193b15425c2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146b7cf3a138cf9efc04fc87e4b45e08"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a146b7cf3a138cf9efc04fc87e4b45e08">sm_register_storage_device</a> (<a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html">STORAGE_DEVICE</a> *device, char *label)</td></tr>
<tr class="memdesc:a146b7cf3a138cf9efc04fc87e4b45e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a device (such as an SD card slot) with smlib to be mounted automatically whenever the device is inserted/connected. This will cause smlib to request notifications from the device driver when the device is connected/disconnected and it will mount the device automatically with the specified drive label.  <a href="#a146b7cf3a138cf9efc04fc87e4b45e08">More...</a><br/></td></tr>
<tr class="separator:a146b7cf3a138cf9efc04fc87e4b45e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050baffcda50f1c40cf39578141763e7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a050baffcda50f1c40cf39578141763e7">sm_mount_volume</a> (char *label, void *storage_device)</td></tr>
<tr class="memdesc:a050baffcda50f1c40cf39578141763e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a volume.  <a href="#a050baffcda50f1c40cf39578141763e7">More...</a><br/></td></tr>
<tr class="separator:a050baffcda50f1c40cf39578141763e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72825d12a01dda79ae7514fd43db0b39"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a72825d12a01dda79ae7514fd43db0b39">sm_dismount_volume</a> (char *label)</td></tr>
<tr class="memdesc:a72825d12a01dda79ae7514fd43db0b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dismounts a mounted volume.  <a href="#a72825d12a01dda79ae7514fd43db0b39">More...</a><br/></td></tr>
<tr class="separator:a72825d12a01dda79ae7514fd43db0b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82074ca3d5c9aecec72879608f8b57d6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a82074ca3d5c9aecec72879608f8b57d6">sm_get_volume_sector_size</a> (char *label)</td></tr>
<tr class="memdesc:a82074ca3d5c9aecec72879608f8b57d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sector size of a mounted volume.  <a href="#a82074ca3d5c9aecec72879608f8b57d6">More...</a><br/></td></tr>
<tr class="separator:a82074ca3d5c9aecec72879608f8b57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42546f1d89f496dc21f12b9291a4019"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ae42546f1d89f496dc21f12b9291a4019">sm_get_file_entry</a> (char *filename, <a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *entry)</td></tr>
<tr class="memdesc:ae42546f1d89f496dc21f12b9291a4019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the directory entry information for a file. <a href="#ae42546f1d89f496dc21f12b9291a4019">More...</a><br/></td></tr>
<tr class="separator:ae42546f1d89f496dc21f12b9291a4019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c051930d83c1c79324bc1b1ef3aff4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a05c051930d83c1c79324bc1b1ef3aff4">sm_find_first_entry</a> (char *path, unsigned char attributes, <a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *entry, <a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *query)</td></tr>
<tr class="memdesc:a05c051930d83c1c79324bc1b1ef3aff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a directory query and finds the 1st entry in the specified directory.  <a href="#a05c051930d83c1c79324bc1b1ef3aff4">More...</a><br/></td></tr>
<tr class="separator:a05c051930d83c1c79324bc1b1ef3aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd85a62788fcb043f5a7440d0157ad"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a9dcd85a62788fcb043f5a7440d0157ad">sm_find_next_entry</a> (<a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *entry, <a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *query)</td></tr>
<tr class="memdesc:a9dcd85a62788fcb043f5a7440d0157ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next entry in a directory.  <a href="#a9dcd85a62788fcb043f5a7440d0157ad">More...</a><br/></td></tr>
<tr class="separator:a9dcd85a62788fcb043f5a7440d0157ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88967d56ae0340d4d5ed57f9a088f792"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a88967d56ae0340d4d5ed57f9a088f792">sm_find_close</a> (<a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *query)</td></tr>
<tr class="memdesc:a88967d56ae0340d4d5ed57f9a088f792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes and frees all resources used by a directory query.  <a href="#a88967d56ae0340d4d5ed57f9a088f792">More...</a><br/></td></tr>
<tr class="separator:a88967d56ae0340d4d5ed57f9a088f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce85e4cd81e0978ee9961ab1267788f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a9ce85e4cd81e0978ee9961ab1267788f">sm_create_directory</a> (char *directory_name)</td></tr>
<tr class="memdesc:a9ce85e4cd81e0978ee9961ab1267788f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory.  <a href="#a9ce85e4cd81e0978ee9961ab1267788f">More...</a><br/></td></tr>
<tr class="separator:a9ce85e4cd81e0978ee9961ab1267788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325adbd4d2d9f994224f7d999ce089a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ad325adbd4d2d9f994224f7d999ce089a">sm_file_delete</a> (char *filename)</td></tr>
<tr class="memdesc:ad325adbd4d2d9f994224f7d999ce089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file.  <a href="#ad325adbd4d2d9f994224f7d999ce089a">More...</a><br/></td></tr>
<tr class="separator:ad325adbd4d2d9f994224f7d999ce089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8e91bc98b12d40ed7288f182a8a424"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a5a8e91bc98b12d40ed7288f182a8a424">sm_file_rename</a> (char *original_filename, char *new_filename)</td></tr>
<tr class="memdesc:a5a8e91bc98b12d40ed7288f182a8a424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a file.  <a href="#a5a8e91bc98b12d40ed7288f182a8a424">More...</a><br/></td></tr>
<tr class="separator:a5a8e91bc98b12d40ed7288f182a8a424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f37cbd43f40dcc26d0a168260ff4133"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a9f37cbd43f40dcc26d0a168260ff4133">sm_file_open</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, char *filename, unsigned char access_flags)</td></tr>
<tr class="memdesc:a9f37cbd43f40dcc26d0a168260ff4133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens or creates a file for read and/or write access.  <a href="#a9f37cbd43f40dcc26d0a168260ff4133">More...</a><br/></td></tr>
<tr class="separator:a9f37cbd43f40dcc26d0a168260ff4133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0b248f06989129498278e97b29208"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a6ce0b248f06989129498278e97b29208">sm_file_alloc</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, uint32_t bytes)</td></tr>
<tr class="memdesc:a6ce0b248f06989129498278e97b29208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough clusters to a file as needed to write the specified number of bytes beyond the current file pointer position.  <a href="#a6ce0b248f06989129498278e97b29208">More...</a><br/></td></tr>
<tr class="separator:a6ce0b248f06989129498278e97b29208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade30ac72c2a83daee73bfe9ce6f9e914"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#ade30ac72c2a83daee73bfe9ce6f9e914">sm_file_seek</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, uint32_t offset, char mode)</td></tr>
<tr class="memdesc:ade30ac72c2a83daee73bfe9ce6f9e914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the file pointer to the specified position.  <a href="#ade30ac72c2a83daee73bfe9ce6f9e914">More...</a><br/></td></tr>
<tr class="separator:ade30ac72c2a83daee73bfe9ce6f9e914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4aee20006c31d0b86a53ea0885a5e4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#aab4aee20006c31d0b86a53ea0885a5e4">sm_file_write</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer, uint32_t bytes_to_write)</td></tr>
<tr class="memdesc:aab4aee20006c31d0b86a53ea0885a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the specified number of bytes to a file synchronously  <a href="#aab4aee20006c31d0b86a53ea0885a5e4">More...</a><br/></td></tr>
<tr class="separator:aab4aee20006c31d0b86a53ea0885a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90fed9ea963df75d22308ca281f6b81"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#af90fed9ea963df75d22308ca281f6b81">sm_file_write_async</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer, uint32_t bytes_to_write, uint16_t *result, <a class="el" href="sm_8h.html#a1b1a8249a2f33303ac6869ba5472500f">SM_ASYNC_CALLBACK</a> callback, void *callback_context)</td></tr>
<tr class="memdesc:af90fed9ea963df75d22308ca281f6b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the specified number of bytes to a file asynchronously.  <a href="#af90fed9ea963df75d22308ca281f6b81">More...</a><br/></td></tr>
<tr class="separator:af90fed9ea963df75d22308ca281f6b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc880ffc90b5d420172575c978a2e2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a17fc880ffc90b5d420172575c978a2e2">sm_file_write_stream</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer, uint32_t bytes_to_write, uint16_t *result, <a class="el" href="sm_8h.html#af07c3c837f09898814640e8d5c12725a">SM_STREAM_CALLBACK</a> callback, void *callback_context)</td></tr>
<tr class="memdesc:a17fc880ffc90b5d420172575c978a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a stream write. This function is used to write data continuosly to the file system. When used with SD cards or other flash devices it will write multiple sectors at once thus increasing performance. It accomplish this without requiring you to allocate large buffers to hold multiple sectors. This function supports both unbuffered and buffered IO but it is recommended that you use unbuffered IO for better performance. Once you initiate a stream write with this function the data you provided will be written to the device, and as soon as the transfer is complete (even while the device is still writing the data) the callback function provided through the callback parameter will be invoked. In this function you must either reload the buffer or replace it with a different one (a pointer to the buffer is passed to the function for this) and set the response argument to SM_STREAM_RESPONSE_READY. As long as you do this everytime and there are no other requests pending the driver will use a single command to write multiple sectors to the device. If you don't have the data ready when the callback function is called you can set the response pointer to SM_STREAM_RESPONSE_SKIP. In that case the driver will complete the multiple sector transfer and release the device for other requests to use, once the device becomes available again the callback function will be called. This process is repeated until you either supply the data and set the response pointer to SM_STREAM_RESPONSE_READY or end the transfer by setting the response pointer to SM_STREAM_RESPONSE_STOP. Once you set the response pointer to SM_STREAM_RESPONSE_STOP the callback function will be called once more to notify you of the result. If an error occurs before that transaction is complete the result pointer will be set to the error code. When the transaction is completed successfully the result pointer is set to SM_SUCCESS, otherwise if the file system is waiting for you to reload the buffer the result pointer is set to SM_AWAITING_DATA. Please see the examples included for more details.  <a href="#a17fc880ffc90b5d420172575c978a2e2">More...</a><br/></td></tr>
<tr class="separator:a17fc880ffc90b5d420172575c978a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2f20e503bf44309d9e5819fecb5314"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#abd2f20e503bf44309d9e5819fecb5314">sm_file_read</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer, uint32_t bytes_to_read, uint32_t *bytes_read)</td></tr>
<tr class="memdesc:abd2f20e503bf44309d9e5819fecb5314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the specified number of bytes from the file.  <a href="#abd2f20e503bf44309d9e5819fecb5314">More...</a><br/></td></tr>
<tr class="separator:abd2f20e503bf44309d9e5819fecb5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855f3d4ebca97695ba09c2b290c3fb1c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a855f3d4ebca97695ba09c2b290c3fb1c">sm_file_read_async</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer, uint32_t bytes_to_read, uint32_t *bytes_read, uint16_t *result, <a class="el" href="sm_8h.html#a1b1a8249a2f33303ac6869ba5472500f">SM_ASYNC_CALLBACK</a> callback, void *callback_context)</td></tr>
<tr class="memdesc:a855f3d4ebca97695ba09c2b290c3fb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the specified number of bytes from the file asynchronously.  <a href="#a855f3d4ebca97695ba09c2b290c3fb1c">More...</a><br/></td></tr>
<tr class="separator:a855f3d4ebca97695ba09c2b290c3fb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a1293b141187a779d59e47ee030bc8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#aa4a1293b141187a779d59e47ee030bc8">sm_file_flush</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file)</td></tr>
<tr class="memdesc:aa4a1293b141187a779d59e47ee030bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the file buffer to the drive and updates the file size and timestamps.  <a href="#aa4a1293b141187a779d59e47ee030bc8">More...</a><br/></td></tr>
<tr class="separator:aa4a1293b141187a779d59e47ee030bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddfac8946d87ed28d4513c2527df320"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a3ddfac8946d87ed28d4513c2527df320">sm_file_close</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file)</td></tr>
<tr class="memdesc:a3ddfac8946d87ed28d4513c2527df320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the file buffer to the drive, updates the file size and timestamps, and closes the file handle.  <a href="#a3ddfac8946d87ed28d4513c2527df320">More...</a><br/></td></tr>
<tr class="separator:a3ddfac8946d87ed28d4513c2527df320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce7c3fe0bf9c09489d5927ae94df7bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sm_8h.html#a6ce7c3fe0bf9c09489d5927ae94df7bc">sm_file_set_buffer</a> (<a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *file, unsigned char *buffer)</td></tr>
<tr class="memdesc:a6ce7c3fe0bf9c09489d5927ae94df7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file buffer. This function is useful if the device driver requires you to use memory from a specific location for asynchronous operations (ie. DMA memory). Or if you want more control about memory allocation. You can open the file with the SM_FILE_FLAG_NO_BUFFERING flag and immediately call this function to set the buffer. That will switch the file handle back to buffered mode.  <a href="#a6ce7c3fe0bf9c09489d5927ae94df7bc">More...</a><br/></td></tr>
<tr class="separator:a6ce7c3fe0bf9c09489d5927ae94df7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file contains all the functions needed to mount and dismount drives, register file system drivers, and perform file I/O operations. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a806e497325bcbdb648e34708dde24af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_ARCHIVE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file is to be archived.</p>

</div>
</div>
<a class="anchor" id="a54a3f8b383bfab2b56fb838c2c66f040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_DIRECTORY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the entry is a directory.</p>

</div>
</div>
<a class="anchor" id="a7597c5e2c9f86c51f933ad5eb2651be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_HIDDEN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file is hidden.</p>

</div>
</div>
<a class="anchor" id="a82e1efb377618c5d91702264871be160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_READ_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file is read-only.</p>

</div>
</div>
<a class="anchor" id="ac045c573c3d3422457555c0aa1f24585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_SYSTEM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file is a system file.</p>

</div>
</div>
<a class="anchor" id="a9b3ffb0c448ba030c3bb0d0591fc58c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_ATTR_VOLUME_ID</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file entry is the volume ID.</p>

</div>
</div>
<a class="anchor" id="a65385aa0bf57e84bfa08754fe0718050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_ACCESS_APPEND</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that if the file exists it should be opened in append mode.</p>

</div>
</div>
<a class="anchor" id="a4f600c4ad23ebe265282ff5daeafdb9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_ACCESS_CREATE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that if the file does not exists it should be created.</p>

</div>
</div>
<a class="anchor" id="a2d450d717247164fdd6cde51cc84634d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_ACCESS_OVERWRITE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that if the file exists it should be overwritten.</p>

</div>
</div>
<a class="anchor" id="afdc50cea776c48a709911da856ad83b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_ACCESS_READ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file should be opened for read access.</p>

</div>
</div>
<a class="anchor" id="a2bd5ea23c380beac7f91336fde56f614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_ACCESS_WRITE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file should be opened for write access.</p>

</div>
</div>
<a class="anchor" id="a6590de3f1d996c8f1ee18774df54a273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_FLAG_NO_BUFFERING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file should be opened in unbuffered mode.</p>

</div>
</div>
<a class="anchor" id="a0643c921c365b78a89196ebcbd47dd0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_FILE_FLAG_OPTIMIZE_FOR_FLASH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the file should be optimized for flash stream writes.</p>

</div>
</div>
<a class="anchor" id="a59a4a35a4b252549dbf658bdf22c07df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_SEEK_CURRENT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the seek operation should start at the current position.</p>

</div>
</div>
<a class="anchor" id="abda07779eb4d21b067319dd9d23424fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_SEEK_END</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specified that the seek operation should set the file pointer at the end of the file.</p>

</div>
</div>
<a class="anchor" id="ac8a752f1a1eaca0183f6b9910c281d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SM_SEEK_START</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies that the seek operation should start at the beginning of the file.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1b1a8249a2f33303ac6869ba5472500f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SM_ASYNC_CALLBACK)(void *context, uint16_t *result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the callback function for asynchronous IO. You can pass a pointer of this type of any of the asynchronous IO functions and it will be called when the operation completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer that was passed to the asynchronous function through the callback_context parameter. </td></tr>
    <tr><td class="paramname">result</td><td>The result of the asynchronous operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#af90fed9ea963df75d22308ca281f6b81" title="Writes the specified number of bytes to a file asynchronously. ">sm_file_write_async</a>, <a class="el" href="sm_8h.html#a855f3d4ebca97695ba09c2b290c3fb1c" title="Reads the specified number of bytes from the file asynchronously. ">sm_file_read_async</a></dd></dl>

</div>
</div>
<a class="anchor" id="af07c3c837f09898814640e8d5c12725a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SM_STREAM_CALLBACK)(void *context, uint16_t *result, unsigned char **buffer, uint16_t *response)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the callback function for asynchronous STREAM IO. You MUST pass a pointer of this type to sm_file_write_stream. When it finished writting your buffer it will call this function. </p>
<p>When smlib calls this function you must do one of the following:</p>
<ol type="1">
<li>If you have more data to be written reload the buffer with it and set response to SM_STREAM_RESPONSE_READY.</li>
<li>If you want to write more data but the data is not yet ready set response to SM_STREAM_RESPONSE_SKIP. The file system will release the IO device and once it becomes available again it will call back so you can reload the buffer.</li>
<li>If you're done writing to the device set response to SM_STREAM_RESPONSE_STOP. </li>
</ol>

</div>
</div>
<a class="anchor" id="a9e6ecb4a67a9ac01594b9ef8808cb8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SM_VOLUME_DISMOUNTED_CALLBACK)(char *label)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is pointer is used to register for notifications when a new volume is dimounted. Once you register this function with sm_register_volume_dismounted_callback it will be called by this module every time a new volume is dismounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The drive label of the mounted volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#ac12cf90dfc90777d18c4af288c415aa6" title="Registers a callback function that will be called everytime a volume is dismounted. ">sm_register_volume_dismounted_callback</a></dd></dl>

</div>
</div>
<a class="anchor" id="a5a9e84d8f6dcc8b7adefda60ac17c34b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SM_VOLUME_MOUNTED_CALLBACK)(char *label)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is pointer is used to register for notifications when a new volume is mounted. Once you register this function with sm_register_volume_mounted_callback it will be called by this module every time a new volume is mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The drive label of the mounted volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#ada581ecde0fce91bb9d3bc21ef4e165b" title="Registers a callback function that will be called everytime a volume is mounted. ">sm_register_volume_mounted_callback</a></dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9ce85e4cd81e0978ee9961ab1267788f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_create_directory </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>directory_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory_name</td><td>The full path of the directory to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a72825d12a01dda79ae7514fd43db0b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_dismount_volume </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dismounts a mounted volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The drive label of the volume to dismount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<p>If this function is called for a volume that is not actually mounted it will return FILESYSTEM_SUCCESS without doing any actual work. </p>

</div>
</div>
<a class="anchor" id="a6ce0b248f06989129498278e97b29208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough clusters to a file as needed to write the specified number of bytes beyond the current file pointer position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">bytes</td><td>The number of bytes to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<p>The purpose of this function is to speed up file writes. It simply allocates the clusters needed, it does not actually expand the file (it's file size remains the same and you still cannot seek beyond the last byte that has already been written. If you call this function before writing to a file the write operation will be much faster, that's all it does. If not all the clusters are used when the file is closed they will be freed. Calling this function also helps to avoid fragmentation. </p>

</div>
</div>
<a class="anchor" id="a3ddfac8946d87ed28d4513c2527df320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the file buffer to the drive, updates the file size and timestamps, and closes the file handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the result codes defined on <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad325adbd4d2d9f994224f7d999ce089a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_delete </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path of the file to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa4a1293b141187a779d59e47ee030bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the file buffer to the drive and updates the file size and timestamps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the result codes defined on <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f37cbd43f40dcc26d0a168260ff4133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>access_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens or creates a file for read and/or write access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>A pointer to a <a class="el" href="struct_s_m___f_i_l_e.html" title="This is the file handle structure. All fields in this structure are reserved for internal use and sho...">SM_FILE</a> structure.</td></tr>
    <tr><td class="paramname">filename</td><td>The full path of the file to open.</td></tr>
    <tr><td class="paramname">access_flags</td><td>One or more of the access flags defined in <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> ORed together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<p>If the SM_FILE_FLAG_NO_BUFFERING access flag is used all IO operations must be done on a sector boundry. You can call sm_get_volume_sector_size to get the sector size of a mounted volume. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#a82074ca3d5c9aecec72879608f8b57d6" title="Gets the sector size of a mounted volume. ">sm_get_volume_sector_size</a></dd></dl>

</div>
</div>
<a class="anchor" id="abd2f20e503bf44309d9e5819fecb5314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the specified number of bytes from the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer where the data will be written to.</td></tr>
    <tr><td class="paramname">bytes_to_read</td><td>The number of bytes to be written.</td></tr>
    <tr><td class="paramname">bytes_read</td><td>A pointer to a 16-bit integer where the number of bytes read will be stored when the operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the error codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> or <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#a855f3d4ebca97695ba09c2b290c3fb1c" title="Reads the specified number of bytes from the file asynchronously. ">sm_file_read_async</a>, <a class="el" href="sm_8h.html#a9f37cbd43f40dcc26d0a168260ff4133" title="Opens or creates a file for read and/or write access. ">sm_file_open</a></dd></dl>

</div>
</div>
<a class="anchor" id="a855f3d4ebca97695ba09c2b290c3fb1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sm_8h.html#a1b1a8249a2f33303ac6869ba5472500f">SM_ASYNC_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the specified number of bytes from the file asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer where the data will be written to.</td></tr>
    <tr><td class="paramname">bytes_to_read</td><td>The number of bytes to be written.</td></tr>
    <tr><td class="paramname">bytes_read</td><td>A pointer to a 32-bit integer where the number of bytes read will be stored when the operation completes. </td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit integer where the result of the asynchronous operation will be stored once it completes. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional function pointer to a callback function to be called when the asynchronous operation completes. </td></tr>
    <tr><td class="paramname">callback_context</td><td>A pointer that will be passed to the callback function when the operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_OP_IN_PROGRESS, otherwise one of the error codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> or <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a8e91bc98b12d40ed7288f182a8a424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_rename </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>original_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>new_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original_filename</td><td>The full path to the file to be renamed.</td></tr>
    <tr><td class="paramname">new_filename</td><td>The full path to the new filename.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<p>Both filenames need to be on the same volume. If they're in different directories the file will be moved. Moving files accross different volumes is not currently supported. </p>

</div>
</div>
<a class="anchor" id="ade30ac72c2a83daee73bfe9ce6f9e914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the file pointer to the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">offset</td><td>The new position of the specified position within the file.</td></tr>
    <tr><td class="paramname">mode</td><td>One of the seek modes listed bellow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#ac8a752f1a1eaca0183f6b9910c281d02" title="Specifies that the seek operation should start at the beginning of the file.">SM_SEEK_START</a> </dd>
<dd>
<a class="el" href="sm_8h.html#a59a4a35a4b252549dbf658bdf22c07df" title="Specifies that the seek operation should start at the current position.">SM_SEEK_CURRENT</a> </dd>
<dd>
<a class="el" href="sm_8h.html#abda07779eb4d21b067319dd9d23424fa" title="Specified that the seek operation should set the file pointer at the end of the file.">SM_SEEK_END</a> </dd></dl>
<p>If an offset other than 0 is specified along with the SM_SEEK_END mode this call will fail. </p>

</div>
</div>
<a class="anchor" id="a6ce7c3fe0bf9c09489d5927ae94df7bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_set_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the file buffer. This function is useful if the device driver requires you to use memory from a specific location for asynchronous operations (ie. DMA memory). Or if you want more control about memory allocation. You can open the file with the SM_FILE_FLAG_NO_BUFFERING flag and immediately call this function to set the buffer. That will switch the file handle back to buffered mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The new file buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab4aee20006c31d0b86a53ea0885a5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_to_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the specified number of bytes to a file synchronously </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to be written.</td></tr>
    <tr><td class="paramname">bytes_to_write</td><td>The number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise it will return one of the result codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> or <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#a6ce0b248f06989129498278e97b29208" title="Allocates enough clusters to a file as needed to write the specified number of bytes beyond the curre...">sm_file_alloc</a>, <a class="el" href="sm_8h.html#af90fed9ea963df75d22308ca281f6b81" title="Writes the specified number of bytes to a file asynchronously. ">sm_file_write_async</a></dd></dl>

</div>
</div>
<a class="anchor" id="af90fed9ea963df75d22308ca281f6b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sm_8h.html#a1b1a8249a2f33303ac6869ba5472500f">SM_ASYNC_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the specified number of bytes to a file asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to be written.</td></tr>
    <tr><td class="paramname">bytes_to_write</td><td>The number of bytes to write</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit integer where the result of the asynchronous write will be stored once the operation completes. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional function pointer to a callback function to be called when the asynchronous operation completes. </td></tr>
    <tr><td class="paramname">callback_context</td><td>A pointer that will be passed to the callback function when the operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_OP_IN_PROGRESS, otherwise it will return one of the result codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> or <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#a6ce0b248f06989129498278e97b29208" title="Allocates enough clusters to a file as needed to write the specified number of bytes beyond the curre...">sm_file_alloc</a></dd></dl>

</div>
</div>
<a class="anchor" id="a17fc880ffc90b5d420172575c978a2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_file_write_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___f_i_l_e.html">SM_FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sm_8h.html#af07c3c837f09898814640e8d5c12725a">SM_STREAM_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a stream write. This function is used to write data continuosly to the file system. When used with SD cards or other flash devices it will write multiple sectors at once thus increasing performance. It accomplish this without requiring you to allocate large buffers to hold multiple sectors. This function supports both unbuffered and buffered IO but it is recommended that you use unbuffered IO for better performance. Once you initiate a stream write with this function the data you provided will be written to the device, and as soon as the transfer is complete (even while the device is still writing the data) the callback function provided through the callback parameter will be invoked. In this function you must either reload the buffer or replace it with a different one (a pointer to the buffer is passed to the function for this) and set the response argument to SM_STREAM_RESPONSE_READY. As long as you do this everytime and there are no other requests pending the driver will use a single command to write multiple sectors to the device. If you don't have the data ready when the callback function is called you can set the response pointer to SM_STREAM_RESPONSE_SKIP. In that case the driver will complete the multiple sector transfer and release the device for other requests to use, once the device becomes available again the callback function will be called. This process is repeated until you either supply the data and set the response pointer to SM_STREAM_RESPONSE_READY or end the transfer by setting the response pointer to SM_STREAM_RESPONSE_STOP. Once you set the response pointer to SM_STREAM_RESPONSE_STOP the callback function will be called once more to notify you of the result. If an error occurs before that transaction is complete the result pointer will be set to the error code. When the transaction is completed successfully the result pointer is set to SM_SUCCESS, otherwise if the file system is waiting for you to reload the buffer the result pointer is set to SM_AWAITING_DATA. Please see the examples included for more details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>An open file handle.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to be written.</td></tr>
    <tr><td class="paramname">bytes_to_write</td><td>The number of bytes to write</td></tr>
    <tr><td class="paramname">result</td><td>A pointer to a 16-bit integer where the result of the asynchronous write will be stored once the operation completes. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional function pointer to a callback function to be called when the asynchronous operation completes. </td></tr>
    <tr><td class="paramname">callback_context</td><td>A pointer that will be passed to the callback function when the operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_OP_IN_PROGRESS, otherwise it will return one of the result codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> or <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="sm_8h.html#a6ce0b248f06989129498278e97b29208" title="Allocates enough clusters to a file as needed to write the specified number of bytes beyond the curre...">sm_file_alloc</a></dd></dl>

</div>
</div>
<a class="anchor" id="a88967d56ae0340d4d5ed57f9a088f792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_find_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes and frees all resources used by a directory query. </p>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a05c051930d83c1c79324bc1b1ef3aff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_find_first_entry </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a directory query and finds the 1st entry in the specified directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path of the directory to query.</td></tr>
    <tr><td class="paramname">attributes</td><td>A list of file attributes ORed together to be used as a query filter. </td></tr>
    <tr><td class="paramname">entry</td><td>A pointer to a <a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html" title="This structure used to store information about a directory entry. It is usually populated by sm_get_f...">SM_DIRECTORY_ENTRY</a> structure that will be populated with the information about the next directory entry. </td></tr>
    <tr><td class="paramname">query</td><td>A pointer to a directory query structure (<a class="el" href="struct_s_m___q_u_e_r_y.html" title="This is the handle of a directory query. All the fields in this structure are reserved for internal u...">SM_QUERY</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9dcd85a62788fcb043f5a7440d0157ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_find_next_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_m___q_u_e_r_y.html">SM_QUERY</a> *&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next entry in a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>A pointer to a <a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html" title="This structure used to store information about a directory entry. It is usually populated by sm_get_f...">SM_DIRECTORY_ENTRY</a> structure that will be populated with the information about the next directory entry. </td></tr>
    <tr><td class="paramname">query</td><td>A pointer to a directory query structure (<a class="el" href="struct_s_m___q_u_e_r_y.html" title="This is the handle of a directory query. All the fields in this structure are reserved for internal u...">SM_QUERY</a>) that has been initialized by sm_find_first_entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae42546f1d89f496dc21f12b9291a4019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_get_file_entry </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html">SM_DIRECTORY_ENTRY</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the directory entry information for a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path of the file.</td></tr>
    <tr><td class="paramname">entry</td><td>A pointer to an <a class="el" href="struct_s_m___d_i_r_e_c_t_o_r_y___e_n_t_r_y.html" title="This structure used to store information about a directory entry. It is usually populated by sm_get_f...">SM_DIRECTORY_ENTRY</a> structure that will be populated with the file information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82074ca3d5c9aecec72879608f8b57d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sm_get_volume_sector_size </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sector size of a mounted volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The drive label of the volume.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a050baffcda50f1c40cf39578141763e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_mount_volume </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>storage_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>A drive label for the volume.</td></tr>
    <tr><td class="paramname">storage_device</td><td>A pointer to the <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> structure of the device driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07206242f3ccfa230cc193b15425c2b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_register_filesystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e_s_y_s_t_e_m.html">FILESYSTEM</a> *&#160;</td>
          <td class="paramname"><em>filesystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a filesystem with smlib. This function needs to be called before a drive can be mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filesystem</td><td>A pointer to the <a class="el" href="struct_f_i_l_e_s_y_s_t_e_m.html" title="Stores all the function pointers needed by this library to interface to a file system driver...">FILESYSTEM</a> structure of the file system driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a146b7cf3a138cf9efc04fc87e4b45e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sm_register_storage_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html">STORAGE_DEVICE</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a device (such as an SD card slot) with smlib to be mounted automatically whenever the device is inserted/connected. This will cause smlib to request notifications from the device driver when the device is connected/disconnected and it will mount the device automatically with the specified drive label. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the <a class="el" href="struct_s_t_o_r_a_g_e___d_e_v_i_c_e.html" title="Contains the interface between fat32lib and the underlying storage device driver. ...">STORAGE_DEVICE</a> structure of the device driver. </td></tr>
    <tr><td class="paramname">label</td><td>A drive label for the volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful it will return FILESYSTEM_SUCCESS, otherwise one of the return codes defined in <a class="el" href="filesystem_8h.html" title="This header file defines the interface used by this module to interface to a file system driver...">filesystem.h</a> and <a class="el" href="sm_8h.html" title="This header file contains all the functions needed to mount and dismount drives, register file system...">sm.h</a> </dd></dl>
<p>You may call this function several times for the same device with different drive labels and if the device has multiple partitions it will mount one in each drive label. </p>

</div>
</div>
<a class="anchor" id="ac12cf90dfc90777d18c4af288c415aa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm_register_volume_dismounted_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sm_8h.html#a9e6ecb4a67a9ac01594b9ef8808cb8d5">SM_VOLUME_DISMOUNTED_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback function that will be called everytime a volume is dismounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A function pointer to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada581ecde0fce91bb9d3bc21ef4e165b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sm_register_volume_mounted_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sm_8h.html#a5a9e84d8f6dcc8b7adefda60ac17c34b">SM_VOLUME_MOUNTED_CALLBACK</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback function that will be called everytime a volume is mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A function pointer to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_24b8f0e80fe3d390cad25eb9724204bd.html">smlib</a></li><li class="navelem"><a class="el" href="sm_8h.html">sm.h</a></li>
    <li class="footer">Copyright &copy; 2013 by <a href="mailto:frodriguez.developer@outlook.com">Fernando Rodriguez</a></li>
  </ul>
</div>
</body>
</html>
